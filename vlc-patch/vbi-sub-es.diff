--- a/modules/demux/vbi.c
+++ b/modules/demux/vbi.c
@@ -45,6 +45,7 @@
 #include <vlc_demux.h>
 #include <vlc_es.h>
 #include <vlc_es_out.h>
+#include <vlc_block.h>
 
 #include "vbi.h"
 
@@ -52,6 +53,8 @@
     demux_t *p_demux;
     es_out_t *p_out;
     es_out_id_t *p_es_vbi;
+    es_out_id_t *p_es_subtitle;
+    block_t *p_block;
     vbi_raw_decoder decoder;
     vbi_sampling_par sp;
     int i_line;
@@ -59,6 +62,7 @@
     int i_picture;
     int i_field;
     int i_line_offset;
+    bool b_subtitle_mode;
 };
 
 static int DemuxOpen( vlc_object_t * );
@@ -66,6 +70,7 @@
 static void DemuxClose( demux_t * );
 static int Demux( demux_t * );
 static int DemuxControl( demux_t *, int, va_list );
+static int ExtractSubtitleData( demux_sys_t *, const uint8_t *, int );
 
 /*****************************************************************************
  * Module descriptor
@@ -73,7 +78,7 @@
 vlc_module_begin()
     set_shortname( "VBI" )
     set_description( N_("VBI and Teletext demuxer") )
-    set_capability( "demux", 10 )
+    set_capability( "demux", 15 )
     set_category( CAT_INPUT )
     set_subcategory( SUBCAT_INPUT_DEMUX )
     add_shortcut( "vbi" )
@@ -81,6 +86,7 @@
     set_callbacks( DemuxOpen, DemuxClose )
 vlc_module_end()
 
+#define VANC_SUBTITLE_MAGIC 0x55 0x4E 0x44 0x52  // "UNDR"
 
 /*****************************************************************************
  * DemuxOpen: opens the VBI demuxer
@@ -95,6 +101,7 @@
     p_sys->i_picture = 0;
     p_sys->i_field = 0;
     p_sys->i_line_offset = 0;
+    p_sys->b_subtitle_mode = false;
 
     /* Initialize VBI decoder */
     vbi_raw_decoder_init( &p_sys->decoder );
@@ -102,6 +109,7 @@
     /* Create VBI ES */
     es_format_t fmt;
     es_format_Init( &fmt, VIDEO_ES, VLC_CODEC_VBI );
+    fmt.i_id = 1;
     p_sys->p_es_vbi = es_out_Add( p_demux->out, &fmt );
 
     /* Check for subtitle mode */
@@ -109,6 +117,15 @@
         p_sys->b_subtitle_mode = true;
         
         /* Create subtitle ES */
+        es_format_t sub_fmt;
+        es_format_Init( &sub_fmt, SPU_ES, VLC_CODEC_UNDERTEXT );
+        sub_fmt.i_id = 2;
+        p_sys->p_es_subtitle = es_out_Add( p_demux->out, &sub_fmt );
+        
+        msg_Info( p_demux, "Undertext subtitle extraction enabled" );
+    } else {
+        p_sys->p_es_subtitle = NULL;
     }
 
     return VLC_SUCCESS;
@@ -125,6 +142,7 @@
     demux_sys_t *p_sys = p_demux->p_sys;
 
     es_out_Del( p_demux->out, p_sys->p_es_vbi );
+    if( p_sys->p_es_subtitle ) es_out_Del( p_demux->out, p_sys->p_es_subtitle );
 
     free( p_sys );
 }
@@ -140,6 +158,7 @@
     demux_sys_t *p_sys = p_demux->p_sys;
     block_t *p_block;
     vbi_event event;
+    uint8_t *p_vanc_data;
 
     p_block = stream_Block( p_demux->s, 0 );
     if( p_block == NULL )
@@ -147,6 +166,20 @@
 
     p_block->i_dts = p_block->i_pts = VLC_TS_INVALID;
 
+    /* Extract VANC data for subtitle processing */
+    if( p_sys->b_subtitle_mode && p_block->i_buffer >= 4 ) {
+        p_vanc_data = p_block->p_buffer;
+        
+        /* Check for Undertext magic bytes */
+        if( p_vanc_data[0] == 0x55 && p_vanc_data[1] == 0x4E && 
+            p_vanc_data[2] == 0x44 && p_vanc_data[3] == 0x52 ) {
+            
+            ExtractSubtitleData( p_sys, p_vanc_data, p_block->i_buffer );
+        }
+    }
+
+    /* Process VBI data normally */
     vbi_raw_decode( &p_sys->decoder, p_block->p_buffer, p_block->i_buffer );
 
     while( vbi_event_poll( &p_sys->decoder, &event, 0 ) )
@@ -158,6 +191,7 @@
             es_out_Send( p_demux->out, p_sys->p_es_vbi, p_block );
         }
     }
+    else block_Release( p_block );
 
     return 1;
 }
@@ -165,3 +199,45 @@
 static int DemuxControl( demux_t *p_demux, int i_query, va_list args )
 {
     return demux_vaControlHelper( p_demux->s, 0, -1, 0, 1, i_query, args );
+}
+
+/*****************************************************************************
+ * ExtractSubtitleData: extracts and processes hidden subtitle data
+ *****************************************************************************/
+static int ExtractSubtitleData( demux_sys_t *p_sys, const uint8_t *p_data, int i_size )
+{
+    if( !p_sys->p_es_subtitle || i_size < 8 )
+        return VLC_EGENERIC;
+
+    /* Skip magic bytes and get data length */
+    const uint8_t *p_subtitle_data = p_data + 4;
+    uint16_t i_data_len = (p_subtitle_data[0] << 8) | p_subtitle_data[1];
+    
+    if( i_data_len > i_size - 6 )
+        return VLC_EGENERIC;
+
+    /* Create subtitle block */
+    block_t *p_subtitle_block = block_Alloc( i_data_len );
+    if( !p_subtitle_block )
+        return VLC_ENOMEM;
+
+    /* Copy subtitle data */
+    memcpy( p_subtitle_block->p_buffer, p_subtitle_data + 2, i_data_len );
+    p_subtitle_block->i_buffer = i_data_len;
+    p_subtitle_block->i_dts = p_subtitle_block->i_pts = VLC_TS_INVALID;
+
+    /* Send subtitle data */
+    es_out_Send( p_sys->p_demux->out, p_sys->p_es_subtitle, p_subtitle_block );
+
+    return VLC_SUCCESS;
+} 